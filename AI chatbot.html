<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AI Chatbot — Single File</title>
    <!-- Tailwind CDN (works in single-file demos) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* minor extras */
        
        html,
        body,
        #app {
            height: 100%
        }
        
        .chat-scroll {
            overscroll-behavior: contain;
        }
        
        .user-bubble {
            background: linear-gradient(180deg, #2563eb, #1e40af);
            color: white;
        }
        
        .ai-bubble {
            background: #f3f4f6;
            color: #0f172a;
        }
        
        pre {
            white-space: pre-wrap
        }
    </style>
</head>

<body class="bg-slate-50">
    <div id="app" class="h-full flex flex-col max-w-4xl mx-auto p-4">
        <header class="flex items-center gap-4 mb-4">
            <div class="flex-1">
                <h1 class="text-2xl font-semibold">AI Chatbot — Single File</h1>
                <p class="text-sm text-slate-600">Paste your OpenAI API key below, then ask anything. (Or point to your server proxy.)</p>
            </div>
            <div class="w-80">
                <label class="text-xs text-slate-600">OpenAI API key (kept in session only)</label>
                <input id="apiKey" type="password" placeholder="sk-..." class="w-full px-3 py-2 rounded-md border" />
                <div class="flex gap-2 mt-2 text-xs">
                    <button id="saveKey" class="px-3 py-1 bg-sky-600 text-white rounded">Save key</button>
                    <button id="clearKey" class="px-3 py-1 bg-white border rounded">Clear</button>
                </div>
            </div>
        </header>

        <main class="flex-1 flex gap-4">
            <section class="w-72 bg-white p-3 rounded-lg shadow-sm h-[70vh] overflow-auto">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-sm font-medium">Controls</h3>
                    <div class="text-xs text-slate-500">Saved chats</div>
                </div>

                <div class="mb-2">
                    <label class="text-xs text-slate-600">Model</label>
                    <select id="modelSelect" class="w-full mt-1 p-2 rounded border">
            <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
            <option value="gpt-4o">gpt-4o</option>
            <option value="gpt-4o-mini">gpt-4o-mini</option>
          </select>
                </div>

                <div class="mb-2">
                    <label class="text-xs text-slate-600">Temperature</label>
                    <input id="temp" type="range" min="0" max="1" step="0.1" value="0.2" />
                </div>

                <div class="flex gap-2 mt-3">
                    <button id="newChat" class="flex-1 px-3 py-2 bg-white border rounded">New chat</button>
                    <button id="exportChat" class="flex-1 px-3 py-2 bg-emerald-600 text-white rounded">Export</button>
                </div>

                <hr class="my-3">

                <div>
                    <h4 class="text-xs text-slate-600 mb-2">Saved conversations</h4>
                    <div id="savedList" class="flex flex-col gap-2 text-sm"></div>
                </div>
            </section>

            <section class="flex-1 flex flex-col h-[70vh]">
                <div id="chat" class="flex-1 bg-white p-4 rounded-lg shadow-sm overflow-auto chat-scroll">
                    <!-- messages -->
                </div>

                <form id="composer" class="mt-3 bg-white p-3 rounded-lg shadow-sm flex gap-3 items-end">
                    <textarea id="prompt" rows="2" placeholder="Type your message... (Shift+Enter for newline)" class="flex-1 p-2 border rounded resize-none"></textarea>
                    <div class="flex flex-col gap-2 shrink-0">
                        <button id="sendBtn" class="px-4 py-2 bg-sky-600 text-white rounded">Send</button>
                        <button id="stopBtn" type="button" class="px-4 py-2 bg-red-500 text-white rounded hidden">Stop</button>
                    </div>
                </form>

                <div class="mt-2 flex gap-2 text-xs">
                    <button id="copyAll" class="px-3 py-1 bg-white border rounded">Copy all</button>
                    <button id="clearAll" class="px-3 py-1 bg-white border rounded">Clear history</button>
                    <div class="flex-1 text-right text-slate-500" id="status">Ready</div>
                </div>
            </section>
        </main>

        <footer class="mt-4 text-xs text-slate-500">
            Single-file demo • Keep key private • For production, run a server proxy (recommended).
        </footer>
    </div>

    <script>
        /* Single-file AI Chatbot
                       - Uses OpenAI ChatCompletions endpoint with streaming
                       - Stores chats in localStorage
                       - IMPORTANT: The API key is used directly from sessionStorage if set.
                    */

        // === Utilities ===
        const $ = id => document.getElementById(id);
        const safeJson = (s) => {
            try {
                return JSON.parse(s)
            } catch (e) {
                return null
            }
        }

        // State
        let conversation = []; // array of {role: 'user'|'assistant'|'system', content}
        let currentAbortController = null;

        // init DOM refs
        const chatEl = $('chat');
        const promptEl = $('prompt');
        const apiKeyInput = $('apiKey');
        const statusEl = $('status');
        const modelSelect = $('modelSelect');
        const tempEl = $('temp');
        const savedListEl = $('savedList');
        const sendBtn = $('sendBtn');
        const stopBtn = $('stopBtn');

        // Load saved key from sessionStorage
        apiKeyInput.value = sessionStorage.getItem('OPENAI_KEY') || '';

        // Load saved conversation from localStorage
        function loadSaved() {
            const raw = localStorage.getItem('singlefile_chat');
            const parsed = safeJson(raw);
            if (parsed && parsed.conversation) {
                conversation = parsed.conversation;
            } else {
                conversation = [{
                    role: 'system',
                    content: "You are a helpful assistant."
                }];
            }
            renderChat();
            // saved list (multiple conversations support)
            const archive = safeJson(localStorage.getItem('singlefile_archive')) || [];
            savedListEl.innerHTML = archive.length ? archive.map((c, i) => `
        <div class="flex items-center justify-between gap-2">
          <div class="truncate">${escapeHtml((c.title||'Chat') )}</div>
          <div class="flex gap-1">
            <button data-load="${i}" class="px-2 py-1 text-xs border rounded">Load</button>
            <button data-del="${i}" class="px-2 py-1 text-xs border rounded">Delete</button>
          </div>
        </div>
      `).join('') : '<div class="text-slate-400 text-xs">No saved conversations</div>';
        }

        function saveCurrent() {
            localStorage.setItem('singlefile_chat', JSON.stringify({
                conversation
            }));
        }

        function escapeHtml(s) {
            if (!s) return '';
            return s.replace(/[&<>"']/g, c => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            })[c]);
        }

        // Render conversation
        function renderChat() {
            chatEl.innerHTML = '';
            conversation.forEach((m, idx) => {
                        if (m.role === 'system') return; // hide system
                        const wrapper = document.createElement('div');
                        wrapper.className = 'mb-4';
                        wrapper.innerHTML = `
          <div class="flex ${m.role==='user' ? 'justify-end' : 'justify-start'}">
            <div class="max-w-[80%] p-3 rounded-xl ${m.role==='user' ? 'user-bubble' : 'ai-bubble'}">
              <div class="text-sm ${m.role==='user' ? 'font-medium' : 'text-slate-800'}">
                ${m.content_html ? m.content_html : `<pre class="text-sm m-0">${escapeHtml(m.content)}</pre>`}
              </div>
            </div>
          </div>
        `;
        chatEl.appendChild(wrapper);
      });
      chatEl.scrollTop = chatEl.scrollHeight;
      saveCurrent();
    }

    // Convert markdown-like links to HTML minimal (very lightweight)
    function contentToHtml(text){
      // Simple newline -> <br>, basic code block handling could be improved
      const escaped = escapeHtml(text);
      const withBreaks = escaped.replace(/\n/g,'<br>');
      // convert links
      return withBreaks.replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" class="underline">$1</a>');
    }

    // Send message
    async function sendMessage(content) {
      if (!content || !content.trim()) return;
      // push user message
      conversation.push({role:'user', content});
      renderChat();
      promptEl.value = '';
      statusEl.textContent = 'Sending...';
      const apiKey = sessionStorage.getItem('OPENAI_KEY');
      if (!apiKey) {
        statusEl.textContent = 'Missing API key. Paste it in the top-right and click Save key.';
        return;
      }

      // Build messages (keep system)
      const system = conversation.find(m=>m.role==='system');
      const messages = [];
      if (system) messages.push({role:'system', content: system.content});
      conversation.filter(m=>m.role!=='system').forEach(m => messages.push({role:m.role, content:m.content}));

      // create assistant placeholder
      const aiPlaceholder = {role:'assistant', content: '', content_html: '<em>...</em>'};
      conversation.push(aiPlaceholder);
      renderChat();
      statusEl.textContent = 'Waiting for AI...';
      stopBtn.classList.remove('hidden');
      sendBtn.disabled = true;

      // Abort controller for stop button
      currentAbortController = new AbortController();
      const model = modelSelect.value;
      const temperature = Number(tempEl.value);

      try {
        // Use Chat Completions streaming (text/event-stream)
        // Endpoint: https://api.openai.com/v1/chat/completions
        // Note: some models or accounts might not allow streaming; if so, change to non-streaming flow.
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer ' + apiKey,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model,
            messages,
            temperature,
            stream: true
          }),
          signal: currentAbortController.signal
        });

        if (!resp.ok) {
          const errText = await resp.text();
          throw new Error(`${resp.status} ${resp.statusText}: ${errText}`);
        }

        // streaming parser for text/event-stream
        const reader = resp.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let done = false;
        let assistantText = '';

        while (!done) {
          const {value, done: doneReading} = await reader.read();
          done = doneReading;
          if (value) {
            const chunk = decoder.decode(value, {stream: true});
            // the stream sends lines like: data: {...}\n\n or data: [DONE]
            const parts = chunk.split(/\n/).filter(Boolean);
            for (const part of parts) {
              // remove leading "data: "
              const line = part.replace(/^data:\s*/, '');
              if (line === '[DONE]') {
                done = true;
                break;
              }
              try {
                const parsed = JSON.parse(line);
                const delta = parsed.choices?.[0]?.delta;
                if (delta?.content) {
                  assistantText += delta.content;
                  aiPlaceholder.content = assistantText;
                  aiPlaceholder.content_html = contentToHtml(assistantText);
                  renderChat();
                }
              } catch(e){
                // ignore parse errors for partial lines
              }
            }
          }
        }

        // finalize assistant content
        aiPlaceholder.content = assistantText;
        aiPlaceholder.content_html = contentToHtml(assistantText);
        renderChat();
        statusEl.textContent = 'Done';
      } catch (err) {
        if (err.name === 'AbortError') {
          statusEl.textContent = 'Stopped by user';
          // leave what was generated so far
        } else {
          statusEl.textContent = 'Error: ' + err.message;
          // replace last assistant with error message
          const last = conversation[conversation.length-1];
          if (last && last.role === 'assistant') {
            last.content = '⚠️ Error: ' + (err.message || 'unknown');
            last.content_html = contentToHtml(last.content);
            renderChat();
          }
        }
      } finally {
        currentAbortController = null;
        stopBtn.classList.add('hidden');
        sendBtn.disabled = false;
      }
    }

    // UI wiring
    $('saveKey').addEventListener('click', ()=> {
      const val = apiKeyInput.value.trim();
      if (!val) {
        alert('Paste your OpenAI API key (sk-...)');
        return;
      }
      sessionStorage.setItem('OPENAI_KEY', val);
      alert('API key saved to sessionStorage (only this tab). For production use a server-side proxy.');
    });

    $('clearKey').addEventListener('click', ()=> {
      sessionStorage.removeItem('OPENAI_KEY');
      apiKeyInput.value = '';
      alert('Key cleared from sessionStorage.');
    });

    $('newChat').addEventListener('click', ()=> {
      if (!confirm('Start a new chat? Current conversation will be archived.')) return;
      // archive current
      const archive = JSON.parse(localStorage.getItem('singlefile_archive')||'[]');
      const title = prompt('Title for archive (optional)', (conversation[1] && conversation[1].content.slice(0,60)) || 'Chat');
      archive.unshift({title: title || 'Chat', conversation});
      localStorage.setItem('singlefile_archive', JSON.stringify(archive.slice(0,30)));
      // reset conversation
      conversation = [{role:'system', content:'You are a helpful assistant.'}];
      saveCurrent();
      loadSaved();
    });

    $('exportChat').addEventListener('click', ()=> {
      const data = conversation.filter(m=>m.role!=='system').map(m=>`${m.role.toUpperCase()}:\n${m.content}\n`).join('\n---\n');
      const blob = new Blob([data], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'chat.txt'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    // saved list events
    savedListEl.addEventListener('click', (e)=>{
      const loadIdx = e.target.getAttribute('data-load');
      const delIdx = e.target.getAttribute('data-del');
      const archive = JSON.parse(localStorage.getItem('singlefile_archive')||'[]');
      if (loadIdx !== null) {
        const item = archive[Number(loadIdx)];
        if (item) {
          conversation = item.conversation || [{role:'system', content:'You are a helpful assistant.'}];
          saveCurrent();
          loadSaved();
        }
      } else if (delIdx !== null) {
        if (!confirm('Delete saved conversation?')) return;
        archive.splice(Number(delIdx),1);
        localStorage.setItem('singlefile_archive', JSON.stringify(archive));
        loadSaved();
      }
    });

    // send button / form
    $('composer').addEventListener('submit', (e)=> {
      e.preventDefault();
      const text = promptEl.value;
      sendMessage(text);
    });

    // stop streaming
    $('stopBtn').addEventListener('click', ()=> {
      if (currentAbortController) currentAbortController.abort();
      stopBtn.classList.add('hidden');
      sendBtn.disabled = false;
    });

    $('copyAll').addEventListener('click', ()=>{
      const plain = conversation.filter(m=>m.role!=='system').map(m=>`${m.role.toUpperCase()}:\n${m.content}`).join('\n\n');
      navigator.clipboard.writeText(plain).then(()=>alert('Copied to clipboard'));
    });

    $('clearAll').addEventListener('click', ()=>{
      if (!confirm('Clear all chat history?')) return;
      conversation = [{role:'system', content:'You are a helpful assistant.'}];
      saveCurrent();
      renderChat();
    });

    // keyboard: Shift+Enter newline handled by textarea; Enter sends
    promptEl.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        $('composer').dispatchEvent(new Event('submit'));
      }
    });

    // initial load
    loadSaved();

    // small helper to load saved key into session (if user pastes and clicks Save)
    window.addEventListener('beforeunload', ()=> saveCurrent());

    // render with html content support
    // patch renderChat to prefer content_html if present (already used)
    </script>
</body>

</html>